// Package sqlitegen provides code generation utilities for SQLite.
package sqlitegen

import (
	"context"
	"strings"

	"crawshaw.io/sqlite"
	"go.uber.org/multierr"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

var initialisms = map[string]string{
	"ip":   "IP",
	"id":   "ID",
	"http": "HTTP",
}

// AddInitialism allows to add a custom initialism so that generated code knows about them.
func AddInitialism(ss ...string) {
	for _, s := range ss {
		low := strings.ToLower(s)
		initialisms[low] = s
	}
}

func getInitialism(s string) (out string, ok bool) {
	s = strings.ToLower(s)
	out, ok = initialisms[s]
	return out, ok
}

// QueryKind defines kinds of queries.
type QueryKind byte

const (
	// QueryKindSingle means that query returns a single row as a result.
	QueryKindSingle QueryKind = iota
	// QueryKindMany means that query returns multiple rows as a result.
	QueryKindMany
	// QueryKindExec means that query doesn't return any rows, but only an error.
	QueryKindExec
)

// QueryTemplate represents a template for a query.
// See qb package for building the query template.
type QueryTemplate struct {
	Name    string
	Kind    QueryKind
	SQL     string
	Inputs  []GoSymbol
	Outputs []GoSymbol
}

// GoSymbol describes a Go variable with name and type.
type GoSymbol struct {
	Name string
	Type Type
}

func (s GoSymbol) String() string {
	return s.Name + " " + s.Type.goString()
}

// GoNameFromSQLName converts a column name into a Go symbol name.
func GoNameFromSQLName(s string, exported bool) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '.'
	})

	for i, p := range parts {
		if !exported && i == 0 {
			continue
		}

		if s, ok := getInitialism(p); ok {
			parts[i] = s
			continue
		}

		parts[i] = cases.Title(language.English).String(p)
	}

	return strings.Join(parts, "")
}

// ExecStmt is a helper function that gets called in the code generated by this package.
func ExecStmt(conn *sqlite.Conn, query string, before func(*sqlite.Stmt), onStep func(int, *sqlite.Stmt) error) (err error) {
	// We want to gracefully handle SQLITE_INTERRUPT errors, because they mean that the parent context
	// got canceled, and we don't want them to appear as real errors in the logs or tests.
	// Returning context.Canceled here directly is a bit ugly, would be nicer if the sqlite package could handle it
	// automatically.

	stmt, err := conn.Prepare(query)
	if err != nil {
		if sqlite.ErrCode(err) == sqlite.SQLITE_INTERRUPT {
			return context.Canceled
		}
		return err
	}
	defer func() {
		err = multierr.Append(err, stmt.Reset())
	}()

	before(stmt)

	for i := 0; true; i++ {
		hasRow, err := stmt.Step()
		if err != nil {
			if sqlite.ErrCode(err) == sqlite.SQLITE_INTERRUPT {
				return context.Canceled
			}
			return err
		}

		if !hasRow {
			break
		}

		if err := onStep(i, stmt); err != nil {
			return err
		}
	}

	return err
}
